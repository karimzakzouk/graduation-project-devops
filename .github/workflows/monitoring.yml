name: Monitoring Deployment
on:
  workflow_dispatch:
  workflow_call:
    inputs:
      cluster_name:
        description: 'EKS Cluster Name'
        required: true
        type: string
      app_namespace:
        description: 'Kubernetes Namespace for the Application'
        required: true
        type: string
      monitoring_namespace:
        description: 'Kubernetes Namespace for Monitoring'
        required: true
        type: string
      argocd_namespace:
        description: 'Kubernetes Namespace for ArgoCD'
        required: true
        type: string
      app_name:
        description: 'Name of the Application'
        required: true
        type: string
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: ''
        type: string

jobs:
  monitoring:
    name: Deploy Monitoring Stack
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5
        
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsInfraRole
          aws-region: us-east-1
          
      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ inputs.cluster_name }} --region us-east-1
        
      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.12.0'
          
      - name: Add Helm Repositories
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          
      - name: Install NGINX Ingress Controller with Helm
        run: |
          if ! helm list -n ingress-nginx | grep -q ingress-nginx; then
            kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -
            helm install ingress-nginx ingress-nginx/ingress-nginx \
              --namespace ingress-nginx \
              --set controller.service.type=LoadBalancer \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"=nlb \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-cross-zone-load-balancing-enabled"=true \
              --set controller.config.use-forwarded-headers=true \
              --set controller.metrics.enabled=true \
              --wait --timeout=10m
          fi
          
      - name: Get NGINX LoadBalancer Hostname
        id: nginx-lb
        run: |
          NGINX_HOSTNAME=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "NGINX LoadBalancer Hostname: $NGINX_HOSTNAME"
          echo "nginx_hostname=$NGINX_HOSTNAME" >> $GITHUB_OUTPUT
          
      - name: Create Grafana Secret
        run: |
          kubectl create namespace ${{ inputs.monitoring_namespace }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl create secret generic grafana-admin-secret \
            --from-literal=admin-password='${{ secrets.GRAFANA_ADMIN_PASSWORD }}' \
            --namespace ${{ inputs.monitoring_namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -
            
      - name: Deploy Monitoring
        run: |
          export MONITORING_NAMESPACE=${{ inputs.monitoring_namespace }}
          export ARGOCD_NAMESPACE=${{ inputs.argocd_namespace }}
          envsubst < ./argocd/monitoring.yml | \
          sed "s/monitoring\.yourdomain\.com/${{ steps.nginx-lb.outputs.nginx_hostname }}/g" | \
          kubectl apply -f -
